{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>This utility library provides some basic utility functions for:</p> <ul> <li>SCConfigManager: Reading from and validating YAML style config files</li> <li>SCLogging: Logging messages to the console and a log file</li> <li>SCLogging: Sending email in plain text or HTML format</li> <li>DateHelper: Date helper functions</li> <li>ExcelReader: Reading data from Excel worksheets, ranges and tables</li> <li>CSVReader: Reading data from CSV files and writing to CSV files</li> </ul> <p>To get started, see the Getting Started page.</p> <p>Use the API Reference navigation to view the API methods for each class.</p>"},{"location":"guide/","title":"Spello Consulting Utility Library Getting Started","text":""},{"location":"guide/#installing-the-library","title":"Installing the library","text":"<p>The library is available from PyPi, so to add it to your Python project use pip:</p> <pre><code>pip install sc_utility\n</code></pre> <p>Or better yet, use UV:</p> <pre><code>uv add sc_utility\n</code></pre>"},{"location":"guide/#configuration-file","title":"Configuration File","text":"<p>The library uses a YAML file for configuration. An example config file (config.yaml.example) is available on Github. Copy this to [your_app_name].yaml before using the library. </p> <p>Here's the example file - the library expects to find the Files and Email sections in the file:</p> <pre><code># Just an example section to show how to set up a section\nAmberAPI:\n    APIKey: somerandomkey342\n    BaseUrl: https://api.amber.com.au/v1\n    Timeout: 15\n\nFiles:\n    LogfileName: logfile.log\n    LogfileMaxLines: 500\n    LogfileVerbosity: detailed\n    ConsoleVerbosity: detailed\n\nEmail:\n    EnableEmail: True\n    SMTPServer: smtp.gmail.com\n    SMTPPort: 587\n    SMTPUsername: me@gmail.com\n    SMTPPassword: &lt;Your SMTP password&gt;\n    SubjectPrefix: \"[Bob Portfolio]: \"\n</code></pre>"},{"location":"guide/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"guide/#section-files","title":"Section: Files","text":"Parameter Description LogfileName The name of the log file, can be a relative or absolute path. LogfileMaxLines Maximum number of lines to keep in the log file. If zero, file will never be truncated. LogfileVerbosity The level of detail captured in the log file. One of: none; error; warning; summary; detailed; debug; all ConsoleVerbosity Controls the amount of information written to the console. One of: error; warning; summary; detailed; debug; all. Errors are written to stderr all other messages are written to stdout"},{"location":"guide/#section-email","title":"Section: Email","text":"Parameter Description EnableEmail Set to True if you want to allow the app to send emails. If True, the remaining settings in this section must be configured correctly. SMTPServer The SMTP host name that supports TLS encryption. If using a Google account, set to smtp.gmail.com SMTPPort The port number to use to connect to the SMTP server. If using a Google account, set to 587 SMTPUsername Your username used to login to the SMTP server. If using a Google account, set to your Google email address. SMTPPassword The password used to login to the SMTP server. If using a Google account, create an app password for the app at https://myaccount.google.com/apppasswords SubjectPrefix Optional. If set, the app will add this text to the start of any email subject line for emails it sends."},{"location":"guide/#example-code","title":"Example code","text":"<p>Here's an example module that shows how to use the library classes. Use the API Reference navigation to view the API methods for each class. The code example and the companion config and Excel files is available in the examples/ folder in the Github repo.</p> <pre><code>import platform\nimport pprint\nimport sys\n\nfrom example_config_schemas import ConfigSchema\nfrom sc_utility import DateHelper, ExcelReader, SCConfigManager, SCLogger\n\nCONFIG_FILE = \"example_config.yaml\"\nEXCEL_FILE = \"sample_excel.xlsx\"\n\n\ndef main():\n    \"\"\"Main function to run the example code.\"\"\"\n    print(f\"Hello from sc-utility running on {platform.system()}\")\n\n    # Get our default schema, validation schema, and placeholders\n    schemas = ConfigSchema()\n\n    # Initialize the SC_ConfigManager class\n    try:\n        config = SCConfigManager(\n            config_file=CONFIG_FILE,\n            default_config=schemas.default,\n            validation_schema=schemas.validation,\n            placeholders=schemas.placeholders\n        )\n    except RuntimeError as e:\n        print(f\"Configuration file error: {e}\", file=sys.stderr)\n        return\n\n    # Print a value from the sample config file\n    print(f\"API key = {config.get('AmberAPI', 'APIKey')}\")\n\n    # Initialize the SC_Logger class\n    try:\n        logger = SCLogger(config.get_logger_settings())\n    except RuntimeError as e:\n        print(f\"Logger initialisation error: {e}\", file=sys.stderr)\n        return\n\n    logger.log_message(\"This is a test message at the summary level.\", \"summary\")\n\n    # Setup email\n    email_settings = config.get_email_settings()\n\n    if email_settings is not None:\n        logger.register_email_settings(email_settings)\n\n        text_msg = \"Hello world from sc-utility example code.\"\n        if logger.send_email(\"Hello world\", text_msg):\n            logger.log_message(\"Email sent OK.\", \"detailed\")\n\n    # Use DateHelper to get the current date and time\n    prior_date = DateHelper.today_add_days(-7)\n    print(f\"Prior date (7 days ago): {prior_date}\")\n\n    # Create an instance of ExcelReader\n    print(\"Testing ExcelReader...\")\n    excel_reader = ExcelReader(EXCEL_FILE)\n\n    # Extract a table\n    try:\n        table_data = excel_reader.extract_data(source_name=\"Table1\", source_type=\"table\")\n    except ImportError as e:\n        print(f\"Error extracting table: {e}\")\n        sys.exit(1)\n    else:\n        print(\"Table data extracted successfully:\\n\")\n        pprint.pprint(table_data)\n\n    # See if we have a fatal error from a previous run\n    if logger.get_fatal_error():\n        print(\"Prior fatal error detected.\")\n        logger.clear_fatal_error()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"reference/configmanager/","title":"Config Manager","text":"<p>Loads the configuration from a YAML file, validates it, and provides access to the configuration values.</p>"},{"location":"reference/configmanager/#sc_utility.sc_config_mgr.SCConfigManager.__init__","title":"<code>__init__(config_file, default_config=None, validation_schema=None, placeholders=None)</code>","text":"<p>Initializes the configuration manager.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>The relative or absolute path to the configuration file.</p> required <code>default_config</code> <code>Optional[dict]</code> <p>A default configuration dict to use if the config file does not exist.</p> <code>None</code> <code>validation_schema</code> <code>Optional[dict]</code> <p>A cerberus style validation schema dict to validate the config file against.</p> <code>None</code> <code>placeholders</code> <code>Optional[dict]</code> <p>A dictionary of placeholders to check in the config. If any of these are found, a exception will be raised.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the config file does not exist and no default config is provided, or if there are YAML errors in the config file.</p>"},{"location":"reference/configmanager/#sc_utility.sc_config_mgr.SCConfigManager.check_for_config_changes","title":"<code>check_for_config_changes()</code>","text":"<p>Check if the configuration file has changed. If it has, reload the configuration.</p> <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>True if the configuration has changed, False otherwise.</p>"},{"location":"reference/configmanager/#sc_utility.sc_config_mgr.SCConfigManager.check_for_placeholders","title":"<code>check_for_placeholders(placeholders)</code>","text":"<p>Recursively scan self._config for any instances of a key found in placeholders.</p> <p>If the keys and values match (including nested), return True.</p> <p>Parameters:</p> Name Type Description Default <code>placeholders</code> <code>dict</code> <p>A dictionary of placeholders to check in the config.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If any placeholder is found in the config file, an exception will be raised with a message indicating the placeholder and its value.</p> <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>True if any placeholders are found in the config, otherwise False.</p>"},{"location":"reference/configmanager/#sc_utility.sc_config_mgr.SCConfigManager.get","title":"<code>get(*keys, default=None)</code>","text":"<p>Retrieve a value from the config dictionary using a sequence of nested keys.</p> Example <p>value = config_mgr.get(\"DeviceType\", \"WebsiteAccessKey\")</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>*keys</code> <p>Sequence of keys to traverse the config dictionary.</p> <code>()</code> <code>default</code> <code>Optional[variable]</code> <p>Value to return if the key path does not exist.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>value</code> <code>variable</code> <p>The value if found, otherwise the default.</p>"},{"location":"reference/configmanager/#sc_utility.sc_config_mgr.SCConfigManager.get_email_settings","title":"<code>get_email_settings(config_section='Email')</code>","text":"<p>Returns the email settings from the config file.</p> <p>Parameters:</p> Name Type Description Default <code>config_section</code> <code>Optional[str]</code> <p>The section in the config file where email settings are stored.</p> <code>'Email'</code> <p>Returns:</p> Name Type Description <code>settings</code> <code>dict</code> <p>A dictionary of email settings or None if email is disabled or not configured correctly.</p>"},{"location":"reference/configmanager/#sc_utility.sc_config_mgr.SCConfigManager.get_logger_settings","title":"<code>get_logger_settings(config_section='Files')</code>","text":"<p>Returns the logger settings from the config file.</p> <p>Parameters:</p> Name Type Description Default <code>config_section</code> <code>Optional[str]</code> <p>The section in the config file where logger settings are stored.</p> <code>'Files'</code> <p>Returns:</p> Name Type Description <code>settings</code> <code>dict</code> <p>A dictionary of logger settings that can be passed to the SCLogger() class initialization.</p>"},{"location":"reference/configmanager/#sc_utility.sc_config_mgr.SCConfigManager.load_config","title":"<code>load_config()</code>","text":"<p>Load the configuration from the config file specified to the init method.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If there are YAML errors in the config file, if placeholders are found, or if validation fails.</p> <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>True if the configuration was loaded successfully, otherwise False.</p>"},{"location":"reference/configmanager/#sc_utility.sc_config_mgr.SCConfigManager.register_logger","title":"<code>register_logger(logger_function)</code>","text":"<p>Registers a logger function to be used for logging messages.</p> <p>Parameters:</p> Name Type Description Default <code>logger_function</code> <code>Callable</code> <p>The function to use for logging messages.</p> required"},{"location":"reference/configmanager/#sc_utility.sc_config_mgr.SCConfigManager.select_file_location","title":"<code>select_file_location(file_name)</code>","text":"<p>Selects the file location for the given file name.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The name of the file to locate. Can be just a file name, or a relative or absolute path.</p> required <p>Returns:</p> Name Type Description <code>file_path</code> <code>Path</code> <p>The full path to the file as a Path object. If the file does not exist in the current directory, it will look in the script directory.</p>"},{"location":"reference/csvreader/","title":"CSV Reader","text":"<p>CSVReader class for extracting data from CSV and updating files. </p> <p>The header_config argument to __init__() is a list of dict objects that defines the expected structure of the CSV file. Each dict object in the list should have the following keys:</p> <ul> <li>name: The name of the column.</li> <li>type: The type of the column, which can be 'str', 'int', 'float', or 'date'.</li> <li>format (optional): A string that defines the format for date or float types (e.g., \"%Y-%m-%d\" for date or \".2f\" for float).</li> <li>match (optional): A boolean indicating if this column should be used for matching records in the merge_data_sets() function.</li> <li>sort (optional): An integer indicating the sort order of the column.</li> <li>minimum (optional): A date or int that defines a minimum value for filtering by date.</li> </ul> <p>For example, consider this CSV file:</p> <pre><code>Symbol,Date,Name,Currency,Price\nACM0006AU,2025-04-28,AB Managed Volatility Equities,AUD,1.82\nCSA0038AU,2025-04-28,Bentham Global Income,AUD,1.00\nETL0018AU,2025-04-28,PIMCO Global Bond Wholesale,AUD,0.90\n</code></pre> <p>The header configuration might look liek this:</p> <pre><code>header_config = [\n    {\n        \"name\": \"Symbol\",\n        \"type\": \"str\",\n        \"match\": True,\n        \"sort\": 2,\n    },\n    {\n        \"name\": \"Date\",\n        \"type\": \"date\",\n        \"format\": \"%Y-%m-%d\",\n        \"match\": True,\n        \"sort\": 1,\n        \"minimum\": None,\n    },\n    {\n        \"name\": \"Name\",\n        \"type\": \"str\",\n    },\n    {\n        \"name\": \"Currency\",\n        \"type\": \"str\",\n    },\n    {\n        \"name\": \"Price\",\n        \"type\": \"float\",\n        \"format\": \".2f\",\n    },\n]\n</code></pre>"},{"location":"reference/csvreader/#sc_utility.sc_csv_reader.CSVReader.__init__","title":"<code>__init__(file_path, header_config=None)</code>","text":"<p>Initialize the CSVReader with the file path.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>The path to the CSV file. If the file does not exist, it won't be created.</p> required <code>header_config</code> <code>Optional(list[dict])</code> <p>The header configuration for the CSV file.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If header_config is not structured correctly.</p> <code>ImportError</code> <p>If the file not exists but doesn't have a valid extension.</p>"},{"location":"reference/csvreader/#sc_utility.sc_csv_reader.CSVReader.merge_data_sets","title":"<code>merge_data_sets(primary_list, append_list)</code>","text":"<p>Merges two lists of dictionaries based on header configuration match fields and sorts the result.</p> <p>Parameters:</p> Name Type Description Default <code>primary_list</code> <code>list[dict]</code> <p>The primary list of dictionaries.</p> required <code>append_list</code> <code>list[dict]</code> <p>The list of dictionaries to append or override.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dictionaries in the lists do not have the same structure.</p> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: The merged and sorted list of dictionaries.</p>"},{"location":"reference/csvreader/#sc_utility.sc_csv_reader.CSVReader.read_csv","title":"<code>read_csv()</code>","text":"<p>Read the CSV file and return its content.</p> <p>If the file does not exist, return None. If the file has a header but no data, returns an empty list.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the CSV file is empty or has no header.</p> <code>ValueError</code> <p>A value read from the CSV file cannot be converted to the expected type as defined in header_config.</p> <p>Returns:</p> Name Type Description <code>data</code> <code>list[dict]</code> <p>A list of rows from the CSV file or None if the file does not exist.</p>"},{"location":"reference/csvreader/#sc_utility.sc_csv_reader.CSVReader.sort_csv_data","title":"<code>sort_csv_data(csv_data)</code>","text":"<p>Sort the CSV data based on the header configuration.</p> <p>Parameters:</p> Name Type Description Default <code>csv_data</code> <code>list[dict]</code> <p>The data read from the CSV file.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: The sorted data.</p>"},{"location":"reference/csvreader/#sc_utility.sc_csv_reader.CSVReader.trim_csv_data","title":"<code>trim_csv_data(csv_data, max_lines=None)</code>","text":"<p>Trim the CSV data based on the header configuration and optionally the max_lines arg.</p> <p>Parameters:</p> Name Type Description Default <code>csv_data</code> <code>list[dict]</code> <p>The data read from the CSV file.</p> required <code>max_lines</code> <code>Optional(int)</code> <p>If provided, the maximum number of lines to return from csv_data. If this is &gt;0 then it will return the first max_lines lines, if &lt;0 then it will return all but the last abs(max_lines) lines. If None, no trimming is done.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: The trimmed data.</p>"},{"location":"reference/csvreader/#sc_utility.sc_csv_reader.CSVReader.update_csv_file","title":"<code>update_csv_file(new_data, new_filename=None)</code>","text":"<p>Appends or merges the new_data into an existing CSV file. If the file does not exist, it will be created.</p> <p>This function will also sort and trim the combined data according to the header configuration.</p> <p>Parameters:</p> Name Type Description Default <code>new_data</code> <code>list[dict]</code> <p>The new data to append or merge.</p> required <code>new_filename</code> <code>Optional(Path | str)</code> <p>If provided, the data will be written to this file instead of the original file.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If there is a problem processign the data.</p> <p>Returns:</p> Name Type Description <code>merged_data</code> <code>list[dict]</code> <p>The merged and sorted data after appending or merging the new_data.</p>"},{"location":"reference/csvreader/#sc_utility.sc_csv_reader.CSVReader.write_csv","title":"<code>write_csv(data, new_filename=None)</code>","text":"<p>Write data to the CSV file.</p> <ol> <li>If the file does not exist, it will be created.</li> <li>If the file exists, it will be overwritten.</li> <li>The header will be written based on the header_config.</li> <li>The data will be written in the order of the header_config.</li> <li>If a header in the data does not exist in the header_config, it will be ignored.</li> <li>If a header in the header_config does not exist in the data, throw an exception.</li> <li>Date fields are formatted according to the format specified in header_config.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[dict]</code> <p>The data to write to the CSV file.</p> required <code>new_filename</code> <code>Optional(Path | str)</code> <p>If provided, the data will be written to this file instead of the original file.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data is empty or if a header in header_config is not found in the data.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the data was written successfully, False otherwise.</p>"},{"location":"reference/datehelper/","title":"Date Helper","text":"<p>Class for simplyify date operations.</p> <p>This class provides static methods to handle date formatting, parsing, and calculations. It defaults to the \"YYYY-MM-DD\" format for date strings, but this can be overridden by passing a different format string. It also handles timezone-aware dates by using the local timezone of the system when parsing and formatting dates.</p>"},{"location":"reference/datehelper/#sc_utility.sc_date_helper.DateHelper.add_days","title":"<code>add_days(start_date, days)</code>  <code>staticmethod</code>","text":"<p>Add days to a date or datetime object.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>date | datetime</code> <p>The date/datetime to which days will be added.</p> required <code>days</code> <code>int</code> <p>The number of days to add.</p> required <p>Returns:</p> Type Description <code>date | datetime | None</code> <p>result (date | datetime) : A new date or datetime object with the added days, or None if start_date or days is None.</p>"},{"location":"reference/datehelper/#sc_utility.sc_date_helper.DateHelper.days_between","title":"<code>days_between(start_date, end_date)</code>  <code>staticmethod</code>","text":"<p>Calculate the number of days between two date or datetime objects.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>date</code> <p>The start date.</p> required <code>end_date</code> <code>date</code> <p>The end date.</p> required <p>Returns:</p> Name Type Description <code>difference</code> <code>int</code> <p>The number of days between the two dates, or None if either date is None.</p>"},{"location":"reference/datehelper/#sc_utility.sc_date_helper.DateHelper.format_date","title":"<code>format_date(date_obj, date_format='%Y-%m-%d')</code>  <code>staticmethod</code>","text":"<p>Format a date object to a string.</p> <p>Parameters:</p> Name Type Description Default <code>date_obj</code> <code>date | datetime</code> <p>The date or datetime object to format.</p> required <code>date_format</code> <code>str</code> <p>The format string to use for formatting the date or datetime.</p> <code>'%Y-%m-%d'</code> <p>Returns:</p> Name Type Description <code>date_str</code> <code>str</code> <p>The formatted date string, or None if date_obj is None.</p>"},{"location":"reference/datehelper/#sc_utility.sc_date_helper.DateHelper.get_file_date","title":"<code>get_file_date(file_path)</code>  <code>staticmethod</code>","text":"<p>Get the last modified date of a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str | Path</code> <p>Path to the file. Can be a string or a Path object.</p> required <p>Returns:</p> Name Type Description <code>date_obj</code> <code>date</code> <p>The last modified date of the file as a date object, or None if the file does not exist.</p>"},{"location":"reference/datehelper/#sc_utility.sc_date_helper.DateHelper.get_file_datetime","title":"<code>get_file_datetime(file_path)</code>  <code>staticmethod</code>","text":"<p>Get the last modified datetime of a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str | Path</code> <p>Path to the file. Can be a string or a Path object.</p> required <p>Returns:</p> Name Type Description <code>datetime_obj</code> <code>datetime</code> <p>The last modified datetime of the file as a date object, or None if the file does not exist.</p>"},{"location":"reference/datehelper/#sc_utility.sc_date_helper.DateHelper.is_valid_date","title":"<code>is_valid_date(date_str, date_format='%Y-%m-%d')</code>  <code>staticmethod</code>","text":"<p>Check if a date or datetime string is valid according to the specified format.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>The date string to check.</p> required <code>date_format</code> <code>Optional[str]</code> <p>The format string to use for checking the date. Defaults to \"%Y-%m-%d\".</p> <code>'%Y-%m-%d'</code> <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>True if the date string is valid, False otherwise.</p>"},{"location":"reference/datehelper/#sc_utility.sc_date_helper.DateHelper.now","title":"<code>now()</code>  <code>staticmethod</code>","text":"<p>Get today's date and time.</p> <p>Returns:</p> Name Type Description <code>result</code> <code>datetime</code> <p>Today's date and time as a date object, using the local timezone.</p>"},{"location":"reference/datehelper/#sc_utility.sc_date_helper.DateHelper.now_str","title":"<code>now_str(datetime_format='%Y-%m-%d %H:%M:%S')</code>  <code>staticmethod</code>","text":"<p>Get the current time in string format.</p> <p>Parameters:</p> Name Type Description Default <code>datetime_format</code> <code>Optional[str]</code> <p>The format string to use for formatting the datetime.</p> <code>'%Y-%m-%d %H:%M:%S'</code> <p>Returns:</p> Name Type Description <code>result</code> <code>str</code> <p>Current time as a formatted string, using the specified datetime format.</p>"},{"location":"reference/datehelper/#sc_utility.sc_date_helper.DateHelper.parse_date","title":"<code>parse_date(date_str, date_format='%Y-%m-%d')</code>  <code>staticmethod</code>","text":"<p>Parse a date string to a date or datetime object.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>The date string to parse.</p> required <code>date_format</code> <code>Optional[str]</code> <p>The format string to use for parsing the date. Defaults to \"%Y-%m-%d\".</p> <code>'%Y-%m-%d'</code> <p>Returns:</p> Name Type Description <code>date_obj</code> <code>date | datetime</code> <p>A date or datetime object representing the parsed date_str, or None if date_str is empty.</p>"},{"location":"reference/datehelper/#sc_utility.sc_date_helper.DateHelper.today","title":"<code>today()</code>  <code>staticmethod</code>","text":"<p>Get today's date.</p> <p>Returns:</p> Name Type Description <code>result</code> <code>date</code> <p>Today's date as a date object, using the local timezone.</p>"},{"location":"reference/datehelper/#sc_utility.sc_date_helper.DateHelper.today_add_days","title":"<code>today_add_days(days)</code>  <code>staticmethod</code>","text":"<p>Get today's date ofset by days.</p> <p>Parameters:</p> Name Type Description Default <code>days</code> <code>int</code> <p>The number of days to offset from today. Can be positive or negative</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>date</code> <p>Today's date offset by the specified number of days.</p>"},{"location":"reference/datehelper/#sc_utility.sc_date_helper.DateHelper.today_str","title":"<code>today_str(date_format='%Y-%m-%d')</code>  <code>staticmethod</code>","text":"<p>Get today's date in string format.</p> <p>Parameters:</p> Name Type Description Default <code>date_format</code> <code>Optional[str]</code> <p>The format string to use for formatting the date.</p> <code>'%Y-%m-%d'</code> <p>Returns:</p> Name Type Description <code>result</code> <code>str</code> <p>Today's date as a formatted string, using the specified date format.</p>"},{"location":"reference/excelreader/","title":"Excel Reader","text":"<p>A class to read and extract data from Excel files (.xlsx, .xlsm, .xlsb).</p> <p>This class provides methods to load workbooks, extract data from sheets, tables, and named ranges, with robust error handling.</p>"},{"location":"reference/excelreader/#sc_utility.sc_excel_reader.ExcelReader.__init__","title":"<code>__init__(file_path)</code>","text":"<p>Initializes the ExcelReader with the path to the Excel file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str | Path</code> <p>Path to the Excel file, specified as a Path object or string.</p> required <p>Raises:</p> Type Description <code>ImportError</code> <p>If the file does not exist, is not a valid Excel file, or if the openpyxl library cannot be imported.</p>"},{"location":"reference/excelreader/#sc_utility.sc_excel_reader.ExcelReader.extract_data","title":"<code>extract_data(source_name, source_type)</code>","text":"<p>Extracts data from an Excel file based on the source type and name.</p> <p>Expected the specified source type to be either: - An entire worksheet with the header in the first row (sheet) - A named range (range) - An Excel table (table)</p> <p>Parameters:</p> Name Type Description Default <code>source_name</code> <code>str</code> <p>Name of the sheet, table, or range to extract.</p> required <code>source_type</code> <code>str</code> <p>Type of source ('sheet', 'table', or 'range').</p> required <p>Raises:</p> Type Description <code>ImportError</code> <p>If the source type is invalid or if there are issues extracting data.</p> <p>Returns:</p> Name Type Description <code>data</code> <code>list[dict]</code> <p>Data extracted as a dictionary.</p>"},{"location":"reference/excelreader/#sc_utility.sc_excel_reader.ExcelReader.extract_from_range","title":"<code>extract_from_range(range_name)</code>","text":"<p>Extracts a table from an Excel file and returns it as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>range_name</code> <code>str</code> <p>Name of the range to extract.</p> required <p>Raises:</p> Type Description <code>ImportError</code> <p>If the table cannot be loaded or if there are issues with the file.</p> <p>Returns:</p> Name Type Description <code>data</code> <code>list[dict]</code> <p>A list containing the range data.</p>"},{"location":"reference/excelreader/#sc_utility.sc_excel_reader.ExcelReader.extract_from_sheet","title":"<code>extract_from_sheet(sheet_name)</code>","text":"<p>Extracts a sheet from an Excel file and returns it as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>sheet_name</code> <code>str</code> <p>Name of the sheet to extract.</p> required <p>Raises:</p> Type Description <code>ImportError</code> <p>If the sheet cannot be loaded or if there are issues with the file.</p> <p>Returns:</p> Name Type Description <code>data</code> <code>list[dict]</code> <p>A list containing the sheet data.</p>"},{"location":"reference/excelreader/#sc_utility.sc_excel_reader.ExcelReader.extract_from_table","title":"<code>extract_from_table(table_name)</code>","text":"<p>Extracts a table from an Excel file and returns it as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table to extract.</p> required <p>Raises:</p> Type Description <code>ImportError</code> <p>If the table cannot be loaded or if there are issues with the file.</p> <p>Returns:</p> Name Type Description <code>data</code> <code>list[dict]</code> <p>A list containing the table data.</p>"},{"location":"reference/excelreader/#sc_utility.sc_excel_reader.ExcelReader.load_excel_workbook","title":"<code>load_excel_workbook(data_only=True, read_only=False)</code>","text":"<p>Load an Excel workbook with robust error handling.</p> <p>Parameters:</p> Name Type Description Default <code>data_only</code> <code>Optional[bool]</code> <p>Whether to return cell values (not formulas).</p> <code>True</code> <code>read_only</code> <code>Optional[bool]</code> <p>Use openpyxl's read-only mode for large files.</p> <code>False</code> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the file cannot be loaded due to various reasons (e.g., file not found, permission denied, invalid format).</p> <p>Returns:</p> Name Type Description <code>object</code> <code>workbook</code> <p>Workbook object or None if loading fails.</p>"},{"location":"reference/logging/","title":"Logging","text":"<p>A class to handle logging messages with different verbosity levels.</p>"},{"location":"reference/logging/#sc_utility.sc_logging.SCLogger.__init__","title":"<code>__init__(logger_settings=None, logfile_name=None, file_verbosity='detailed', console_verbosity='summary', max_lines=10000)</code>","text":"<p>Initializes the logger with configuration settings.</p> <p>If logger_settings are provided, it will override the individual parameters.</p> <p>Parameters:</p> Name Type Description Default <code>logger_settings</code> <code>Optional[dict]</code> <p>A dictionary containing logger settings. If provided, it should include the same keys as the individual parameters below:</p> <code>None</code> <code>logfile_name</code> <code>Optional[str]</code> <p>The name of the log file. If None, no file logging will be done.</p> <code>None</code> <code>file_verbosity</code> <code>Optional[str]</code> <p>Verbosity level for file logging</p> <code>'detailed'</code> <code>console_verbosity</code> <code> (Optional[str]</code> <p>Verbosity level for console logging</p> <code>'summary'</code> <code>max_lines</code> <code> (Optional[int]</code> <p>Maximum number of lines to keep in the log file</p> <code>10000</code>"},{"location":"reference/logging/#sc_utility.sc_logging.SCLogger.clear_fatal_error","title":"<code>clear_fatal_error()</code>","text":"<p>Clear a previously logged fatal error.</p> <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>True if the file was deleted, False if it did not exist.</p>"},{"location":"reference/logging/#sc_utility.sc_logging.SCLogger.get_fatal_error","title":"<code>get_fatal_error()</code>","text":"<p>Returns True if a fatal error was previously reported, false otherwise.</p>"},{"location":"reference/logging/#sc_utility.sc_logging.SCLogger.get_os","title":"<code>get_os()</code>","text":"<p>Returns the name of the operating system.</p> <p>Returns:</p> Name Type Description <code>os_string</code> <code>str</code> <p>The name of the operating system in lowercase.</p>"},{"location":"reference/logging/#sc_utility.sc_logging.SCLogger.get_process_id","title":"<code>get_process_id()</code>","text":"<p>Returns the process ID of the current process.</p> <p>Returns:</p> Name Type Description <code>process_id</code> <code>int</code> <p>The process ID of the current process.</p>"},{"location":"reference/logging/#sc_utility.sc_logging.SCLogger.is_probable_path","title":"<code>is_probable_path(possible_path)</code>","text":"<p>Checks if the given string or Path object is likely to be a file path.</p> <p>This method checks if the string is an absolute path, contains a path separator, or has a file extension.</p> <p>Parameters:</p> Name Type Description Default <code>possible_path</code> <code>str</code> <p>The string to check.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>True if the string is likely a file path, False otherwise.</p>"},{"location":"reference/logging/#sc_utility.sc_logging.SCLogger.log_fatal_error","title":"<code>log_fatal_error(message, report_stack=False, calling_function=None)</code>","text":"<p>Log a fatal error, send an email if configured to so and then exit the program.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to log.</p> required <code>report_stack</code> <code>Optional[bool]</code> <p>If True, include the stack trace in the log message.</p> <code>False</code> <code>calling_function</code> <code>Optional[str]</code> <p>The name of the function that called this method, if known. If None, the calling function will be determined automatically.</p> <code>None</code> <p>Raises:</p> Type Description <code>SystemExit</code> <p>Exits the program with a status code of 1 after logging the fatal error.</p>"},{"location":"reference/logging/#sc_utility.sc_logging.SCLogger.log_message","title":"<code>log_message(message, verbosity='summary')</code>","text":"<p>Writes a log message to the console and/or a file based on verbosity settings.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to log.</p> required <code>verbosity</code> <code>str</code> <p>The verbosity level for the message. Must be one of \"none\", \"error\", \"warning\", \"summary\", \"detailed\", \"debug\", or \"all\".</p> <code>'summary'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid verbosity level is provided.</p>"},{"location":"reference/logging/#sc_utility.sc_logging.SCLogger.register_email_settings","title":"<code>register_email_settings(email_settings)</code>","text":"<p>Registers email settings for sending emails.</p> <p>Use the SCConfigManager.get_email_settings() method to get a dictionary containing the email settings. Otherwise, you can pass a dictionary directly to this method with these keys:     SendEmailsTo: str, the email address to send emails to     SMTPServer: str, the SMTP server address     SMTPPort: int, the SMTP server port (optional, defaults to 587)     SMTPUsername: str, the username for the SMTP server     SMTPPassword: str, the password for the SMTP server (preferably an App Password)     SubjectPrefix: str, a prefix for email subjects (optional, default to None)</p> <p>Parameters:</p> Name Type Description Default <code>email_settings</code> <code>Optional[dict]</code> <p>A dictionary containing email settings. If empty or None, no email settings will be registered.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If email_settings is not a dictionary.</p> <code>ValueError</code> <p>If any required keys are missing from the email_settings dictionary.</p>"},{"location":"reference/logging/#sc_utility.sc_logging.SCLogger.select_file_location","title":"<code>select_file_location(file_name)</code>","text":"<p>Selects the file location for the given file name.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The name of the file to locate. Can be just a file name, or a relative or absolute path.</p> required <p>Returns:</p> Name Type Description <code>location</code> <code>Path</code> <p>The full path to the file as a Path object. If the file does not exist in the current directory, it will look in the script directory.</p>"},{"location":"reference/logging/#sc_utility.sc_logging.SCLogger.send_email","title":"<code>send_email(subject, body, test_mode=False)</code>","text":"<p>Sends an email using the SMTP server previously specified in register_email_settings().</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>The subject of the email.</p> required <code>body</code> <code>str</code> <p>The body of the email. This argument can be one of 4 things: 1. A string containing the HTML body of the email 2. A string or Path containing the path to an HTML file to read the body from 3. A string containing the text body of the email 4. A string or Path containing the path to an text file to read the body from</p> required <code>test_mode</code> <code>bool</code> <p>If True, the email will not be sent, but a message will be logged indicating that the email would have been sent. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>result</code> <code>bool</code> <p>True if the email was sent successfully, False otherwise.</p>"},{"location":"reference/logging/#sc_utility.sc_logging.SCLogger.set_fatal_error","title":"<code>set_fatal_error(message)</code>","text":"<p>Create a fatal error tracking file and write the message to it.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message to write to the fatal error file.</p> required"},{"location":"reference/logging/#sc_utility.sc_logging.SCLogger.trim_logfile","title":"<code>trim_logfile()</code>","text":"<p>Trims the log file to the maximum number of lines specified.</p>"}]}